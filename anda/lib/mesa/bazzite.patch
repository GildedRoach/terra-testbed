From cc3cc28e7b1e76d3640be7a497271475fdcfc550 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 15 Mar 2025 16:39:08 +0100
Subject: [PATCH 1/8] [BEGIN] SteamOS Changes

-- 
2.50.1


From 21b062a757a202dcb737d40442b6145c34bb1e48 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Fri, 14 Jan 2022 15:58:45 +0100
Subject: [PATCH 2/8] STEAMOS: radv: min image count override for FH5

Otherwise in combination with the vblank time reservation in
gamescope the game could get stuck in low power states.
---
 src/util/00-radv-defaults.conf | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/util/00-radv-defaults.conf b/src/util/00-radv-defaults.conf
index b82e8d4da4d..c8d059571ad 100644
--- a/src/util/00-radv-defaults.conf
+++ b/src/util/00-radv-defaults.conf
@@ -234,5 +234,9 @@ Application bugs worked around in this file:
         <application name="Total War: WARHAMMER III" application_name_match="TotalWarhammer3">
             <option name="radv_disable_depth_storage" value="true"/>
         </application>
+
+        <application name="Forza Horizon 5" application_name_match="ForzaHorizon5.exe">
+            <option name="vk_x11_override_min_image_count" value="4" />
+        </application>
     </device>
 </driconf>
-- 
2.50.1


From e837814b4f33e48eaf6a79975cb738da39ed0fd2 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 22 Feb 2024 22:32:45 +0100
Subject: [PATCH 3/8] STEAMOS: Dynamic swapchain override for gamescope limiter
 for DRI3 only

The original patch (from Bas) contained WSI VK support too but it's
been removed because the Gamescope WSI layer already handles that.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 .../frontends/dri/loader_dri3_helper.c        | 42 ++++++++++++++++++-
 .../frontends/dri/loader_dri3_helper.h        |  1 +
 2 files changed, 41 insertions(+), 2 deletions(-)

diff --git a/src/gallium/frontends/dri/loader_dri3_helper.c b/src/gallium/frontends/dri/loader_dri3_helper.c
index a795d45ce29..435ea2405a8 100644
--- a/src/gallium/frontends/dri/loader_dri3_helper.c
+++ b/src/gallium/frontends/dri/loader_dri3_helper.c
@@ -297,6 +297,30 @@ dri3_update_max_num_back(struct loader_dri3_drawable *draw)
    }
 }
 
+static unsigned
+gamescope_swapchain_override()
+{
+   const char *path = getenv("GAMESCOPE_LIMITER_FILE");
+   if (!path)
+      return 0;
+
+   static simple_mtx_t mtx = SIMPLE_MTX_INITIALIZER;
+   static int fd = -1;
+
+   simple_mtx_lock(&mtx);
+   if (fd < 0) {
+      fd = open(path, O_RDONLY);
+   }
+   simple_mtx_unlock(&mtx);
+
+   if (fd < 0)
+      return 0;
+
+   uint32_t override_value = 0;
+   pread(fd, &override_value, sizeof(override_value), 0);
+   return override_value;
+}
+
 void
 loader_dri3_set_swap_interval(struct loader_dri3_drawable *draw, int interval)
 {
@@ -311,10 +335,12 @@ loader_dri3_set_swap_interval(struct loader_dri3_drawable *draw, int interval)
     * PS. changing from value A to B and A < B won't cause swap out of order but
     * may still gets wrong target_msc value at the beginning.
     */
-   if (draw->swap_interval != interval)
+   if (draw->orig_swap_interval != interval)
       loader_dri3_swapbuffer_barrier(draw);
 
-   draw->swap_interval = interval;
+   draw->orig_swap_interval = interval;
+   if (gamescope_swapchain_override() != 1)
+      draw->swap_interval = interval;
 }
 
 static void
@@ -443,6 +469,12 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
 
    draw->swap_interval = dri_get_initial_swap_interval(draw->dri_screen_render_gpu);
 
+   draw->orig_swap_interval = draw->swap_interval;
+
+   unsigned gamescope_override = gamescope_swapchain_override();
+   if (gamescope_override == 1)
+      draw->swap_interval = 1;
+
    dri3_update_max_num_back(draw);
 
    /* Create a new drawable */
@@ -1085,6 +1117,12 @@ loader_dri3_swap_buffers_msc(struct loader_dri3_drawable *draw,
    if (draw->type == LOADER_DRI3_DRAWABLE_WINDOW) {
       dri3_fence_reset(draw->conn, back);
 
+      unsigned gamescope_override = gamescope_swapchain_override();
+      if (gamescope_override == 1)
+         draw->swap_interval = 1;
+      else
+         draw->swap_interval = draw->orig_swap_interval;
+
       /* Compute when we want the frame shown by taking the last known
        * successful MSC and adding in a swap interval for each outstanding swap
        * request. target_msc=divisor=remainder=0 means "Use glXSwapBuffers()
diff --git a/src/gallium/frontends/dri/loader_dri3_helper.h b/src/gallium/frontends/dri/loader_dri3_helper.h
index 26f138d1b83..3f0f3f66fac 100644
--- a/src/gallium/frontends/dri/loader_dri3_helper.h
+++ b/src/gallium/frontends/dri/loader_dri3_helper.h
@@ -169,6 +169,7 @@ struct loader_dri3_drawable {
    bool block_on_depleted_buffers;
    bool queries_buffer_age;
    int swap_interval;
+   int orig_swap_interval;
 
    const struct loader_dri3_vtable *vtable;
 
-- 
2.50.1


From 354cf8783e49b082c97982f2e5be305ad6e4ab50 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 15 Mar 2025 16:39:25 +0100
Subject: [PATCH 4/8] [BEGIN] SteamOS Backports

-- 
2.50.1


From c5a4eab20075dfa2f2bdfb87e55ecec262ef00f6 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 15 Mar 2025 16:39:33 +0100
Subject: [PATCH 5/8] [BEGIN] Our Mesa backports

-- 
2.50.1


From 221b11df6d9cd7b66c8502fa51d8d72cfc377e5e Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Mon, 24 Mar 2025 19:50:51 +0100
Subject: [PATCH 6/8] Revert "winsys/amdgpu: use VM_ALWAYS_VALID for all VRAM
 and GTT allocations"

This reverts commit 8c91624614c1f939974fe0d2d1a3baf83335cecb.

Messes with AutoVRAM, who would have thought?
---
 src/gallium/winsys/amdgpu/drm/amdgpu_bo.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
index d5646e9660b..a51348b44a8 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
@@ -624,11 +624,6 @@ static struct amdgpu_winsys_bo *amdgpu_create_bo(struct amdgpu_winsys *aws,
    if (flags & RADEON_FLAG_GTT_WC)
       request.flags |= AMDGPU_GEM_CREATE_CPU_GTT_USWC;
 
-   if (aws->info.has_vm_always_valid &&
-       initial_domain & (RADEON_DOMAIN_VRAM_GTT | RADEON_DOMAIN_DOORBELL) &&
-       flags & RADEON_FLAG_NO_INTERPROCESS_SHARING)
-      request.flags |= AMDGPU_GEM_CREATE_VM_ALWAYS_VALID;
-
    if (flags & RADEON_FLAG_DISCARDABLE &&
        aws->info.drm_minor >= 47)
       request.flags |= AMDGPU_GEM_CREATE_DISCARDABLE;
-- 
2.50.1


From 21c90507cdbb7c2ca23b5d59421b28ac8081051f Mon Sep 17 00:00:00 2001
From: Kyle Gospodnetich <me@kylegospodneti.ch>
Date: Sun, 18 May 2025 09:40:01 -0700
Subject: [PATCH 7/8] [BEGIN] Proton-GE Patches

-- 
2.50.1


From 942ac03422d32e31102e3bff506f28ab6aeca18f Mon Sep 17 00:00:00 2001
From: Kyle Gospodnetich <me@kylegospodneti.ch>
Date: Sun, 18 May 2025 09:42:23 -0700
Subject: [PATCH 8/8] radv: min image count patch for Wine Wayland/Path of
 Exile 2 Credit to Glorious Eggroll.

---
 src/amd/vulkan/radv_instance.c       |  2 +-
 src/asahi/vulkan/hk_instance.c       |  2 +-
 src/freedreno/vulkan/tu_device.cc    |  2 +-
 src/intel/vulkan/anv_instance.c      |  2 +-
 src/intel/vulkan_hasvk/anv_device.c  |  2 +-
 src/nouveau/vulkan/nvk_instance.c    |  2 +-
 src/panfrost/vulkan/panvk_instance.c |  2 +-
 src/util/00-mesa-defaults.conf       | 10 ++++++----
 src/util/driconf.h                   |  4 ++--
 src/virtio/vulkan/vn_instance.c      |  2 +-
 src/vulkan/wsi/wsi_common.c          |  2 +-
 src/vulkan/wsi/wsi_common.h          |  4 ++++
 src/vulkan/wsi/wsi_common_private.h  |  3 ++-
 src/vulkan/wsi/wsi_common_wayland.c  | 21 +++++++++++++++++----
 src/vulkan/wsi/wsi_common_x11.c      |  4 ++--
 15 files changed, 42 insertions(+), 22 deletions(-)

diff --git a/src/amd/vulkan/radv_instance.c b/src/amd/vulkan/radv_instance.c
index 6bcf18847bd..2773003911b 100644
--- a/src/amd/vulkan/radv_instance.c
+++ b/src/amd/vulkan/radv_instance.c
@@ -151,7 +151,7 @@ static const struct debug_control trace_options[] = {
 static const driOptionDescription radv_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_ADAPTIVE_SYNC(true)
-      DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
+      DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
       DRI_CONF_VK_KHR_PRESENT_WAIT(false)
diff --git a/src/asahi/vulkan/hk_instance.c b/src/asahi/vulkan/hk_instance.c
index 69e315ff979..b0361133793 100644
--- a/src/asahi/vulkan/hk_instance.c
+++ b/src/asahi/vulkan/hk_instance.c
@@ -80,7 +80,7 @@ hk_EnumerateInstanceExtensionProperties(const char *pLayerName,
 static const driOptionDescription hk_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_ADAPTIVE_SYNC(true)
-      DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
+      DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
       DRI_CONF_VK_KHR_PRESENT_WAIT(false)
diff --git a/src/freedreno/vulkan/tu_device.cc b/src/freedreno/vulkan/tu_device.cc
index 2c72aff780d..f9d95c63bbe 100644
--- a/src/freedreno/vulkan/tu_device.cc
+++ b/src/freedreno/vulkan/tu_device.cc
@@ -1671,7 +1671,7 @@ tu_destroy_physical_device(struct vk_physical_device *device)
 
 static const driOptionDescription tu_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
-      DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
+      DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_KHR_PRESENT_WAIT(false)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
diff --git a/src/intel/vulkan/anv_instance.c b/src/intel/vulkan/anv_instance.c
index 268a5f3425b..0ab889654ae 100644
--- a/src/intel/vulkan/anv_instance.c
+++ b/src/intel/vulkan/anv_instance.c
@@ -10,7 +10,7 @@
 static const driOptionDescription anv_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_ADAPTIVE_SYNC(true)
-      DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
+      DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_KHR_PRESENT_WAIT(false)
       DRI_CONF_VK_XWAYLAND_WAIT_READY(false)
diff --git a/src/intel/vulkan_hasvk/anv_device.c b/src/intel/vulkan_hasvk/anv_device.c
index 81f08e50e5d..7e9d43df7ce 100644
--- a/src/intel/vulkan_hasvk/anv_device.c
+++ b/src/intel/vulkan_hasvk/anv_device.c
@@ -65,7 +65,7 @@
 static const driOptionDescription anv_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_ADAPTIVE_SYNC(true)
-      DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
+      DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_KHR_PRESENT_WAIT(false)
       DRI_CONF_VK_XWAYLAND_WAIT_READY(true)
diff --git a/src/nouveau/vulkan/nvk_instance.c b/src/nouveau/vulkan/nvk_instance.c
index 37e7abe1584..29da7e3a0b3 100644
--- a/src/nouveau/vulkan/nvk_instance.c
+++ b/src/nouveau/vulkan/nvk_instance.c
@@ -98,7 +98,7 @@ nvk_init_debug_flags(struct nvk_instance *instance)
 static const driOptionDescription nvk_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_ADAPTIVE_SYNC(true)
-      DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
+      DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
       DRI_CONF_VK_KHR_PRESENT_WAIT(false)
diff --git a/src/panfrost/vulkan/panvk_instance.c b/src/panfrost/vulkan/panvk_instance.c
index 31abc8f4369..8c8f7a8ca0c 100644
--- a/src/panfrost/vulkan/panvk_instance.c
+++ b/src/panfrost/vulkan/panvk_instance.c
@@ -151,7 +151,7 @@ panvk_kmod_free(const struct pan_kmod_allocator *allocator, void *data)
 static const driOptionDescription panvk_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_ADAPTIVE_SYNC(true)
-      DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
+      DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
       DRI_CONF_VK_KHR_PRESENT_WAIT(false)
diff --git a/src/util/00-mesa-defaults.conf b/src/util/00-mesa-defaults.conf
index d42526732fa..eaab8afc3e9 100644
--- a/src/util/00-mesa-defaults.conf
+++ b/src/util/00-mesa-defaults.conf
@@ -634,24 +634,24 @@ TODO: document the other workarounds.
 
         <application name="gfxbench" executable="testfw_app">
             <option name="mesa_glthread_app_profile" value="0" />
-            <option name="vk_x11_override_min_image_count" value="2" />
+            <option name="vk_override_min_image_count" value="2" />
             <option name="vk_wsi_force_bgra8_unorm_first" value="true" />
         </application>
 
         <application name="Rainbow Six Siege (Vulkan)" executable="RainbowSix_Vulkan.exe">
-            <option name="vk_x11_override_min_image_count" value="2" />
+            <option name="vk_override_min_image_count" value="2" />
             <option name="vk_x11_strict_image_count" value="true" />
         </application>
 
         <application name="Rainbow Six Extraction (Wine)" executable="R6-Extraction.exe">
-            <option name="vk_x11_override_min_image_count" value="2" />
+            <option name="vk_override_min_image_count" value="2" />
             <option name="vk_x11_strict_image_count" value="true" />
         </application>
 
         <!-- Workaround for Hades: Vulkan backend of the game is not starting
              if the implementation returns more than 3 swapchain images. -->
         <application name="Hades" executable="Hades.exe">
-            <option name="vk_x11_override_min_image_count" value="3" />
+            <option name="vk_override_min_image_count" value="3" />
             <option name="vk_x11_strict_image_count" value="true" />
         </application>
 
@@ -712,10 +712,12 @@ TODO: document the other workarounds.
 
         <application name="Path of Exile" executable="PathOfExile_x64Steam.exe">
             <option name="vk_zero_vram" value="true" />
+            <option name="vk_override_min_image_count" value="3" />
         </application>
 
         <application name="Path of Exile" executable="PathOfExileSteam.exe">
             <option name="vk_zero_vram" value="true" />
+            <option name="vk_override_min_image_count" value="3" />
         </application>
 
         <application name="X4 Foundations" executable="X4">
diff --git a/src/util/driconf.h b/src/util/driconf.h
index 8faa15fb560..c94de3f45fe 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -449,8 +449,8 @@
    DRI_CONF_OPT_B(vk_wsi_force_swapchain_to_current_extent, def, \
                   "Force VkSwapchainCreateInfoKHR::imageExtent to be VkSurfaceCapabilities2KHR::currentExtent")
 
-#define DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(def) \
-   DRI_CONF_OPT_I(vk_x11_override_min_image_count, def, 0, 999, \
+#define DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(def) \
+   DRI_CONF_OPT_I(vk_override_min_image_count, def, 0, 999, \
                   "Override the VkSurfaceCapabilitiesKHR::minImageCount (0 = no override)")
 
 #define DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(def) \
diff --git a/src/virtio/vulkan/vn_instance.c b/src/virtio/vulkan/vn_instance.c
index 1942d77f67c..23c8e19188c 100644
--- a/src/virtio/vulkan/vn_instance.c
+++ b/src/virtio/vulkan/vn_instance.c
@@ -70,8 +70,8 @@ static const struct vk_instance_extension_table
 static const driOptionDescription vn_dri_options[] = {
    /* clang-format off */
    DRI_CONF_SECTION_PERFORMANCE
+      DRI_CONF_VK_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
-      DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_XWAYLAND_WAIT_READY(true)
       DRI_CONF_VENUS_IMPLICIT_FENCING(false)
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index f78e4baa22a..047d5dcdeaf 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -220,7 +220,7 @@ wsi_device_init(struct wsi_device *wsi,
 #endif
 
 #ifdef VK_USE_PLATFORM_WAYLAND_KHR
-   result = wsi_wl_init_wsi(wsi, alloc, pdevice);
+   result = wsi_wl_init_wsi(wsi, alloc, pdevice, dri_options);
    if (result != VK_SUCCESS)
       goto fail;
 #endif
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index 44c81ccddf0..a97e7c2a948 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -209,6 +209,10 @@ struct wsi_device {
    struct {
       /* Don't use the commit-timing protocol for pacing */
       bool disable_timestamps;
+
+      /* Override the minimum number of images on the swapchain.
+       * 0 = no override */
+      double override_minImageCount;
    } wayland;
 
    /*
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index f138fee5519..1d1b55ac7e5 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -420,7 +420,8 @@ void wsi_x11_finish_wsi(struct wsi_device *wsi_device,
                         const VkAllocationCallbacks *alloc);
 VkResult wsi_wl_init_wsi(struct wsi_device *wsi_device,
                          const VkAllocationCallbacks *alloc,
-                         VkPhysicalDevice physical_device);
+                         VkPhysicalDevice physical_device,
+                         const struct driOptionCache *dri_options);
 void wsi_wl_finish_wsi(struct wsi_device *wsi_device,
                        const VkAllocationCallbacks *alloc);
 VkResult wsi_win32_init_wsi(struct wsi_device *wsi_device,
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index dd15d03846b..df68d2ea006 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -58,6 +58,7 @@
 #include <util/u_dynarray.h>
 #include <util/anon_file.h>
 #include <util/os_time.h>
+#include <util/xmlconfig.h>
 
 #include <loader/loader_wayland_helper.h>
 
@@ -1668,9 +1669,12 @@ wsi_wl_surface_get_support(VkIcdSurfaceBase *surface,
 #define WSI_WL_DEFAULT_NUM_IMAGES 3
 
 static uint32_t
-wsi_wl_surface_get_min_image_count(struct wsi_wl_display *display,
+wsi_wl_surface_get_min_image_count(struct wsi_device *wsi_device, struct wsi_wl_display *display,
                                    const VkSurfacePresentModeEXT *present_mode)
 {
+   if (wsi_device->wayland.override_minImageCount)
+      return wsi_device->wayland.override_minImageCount;
+
    if (present_mode) {
       return present_mode->presentMode == VK_PRESENT_MODE_MAILBOX_KHR ?
              WSI_WL_BUMPED_NUM_IMAGES : WSI_WL_DEFAULT_NUM_IMAGES;
@@ -1719,7 +1723,7 @@ wsi_wl_surface_get_capabilities(VkIcdSurfaceBase *icd_surface,
       display = &temp_display;
    }
 
-   caps->minImageCount = wsi_wl_surface_get_min_image_count(display, present_mode);
+   caps->minImageCount = wsi_wl_surface_get_min_image_count(wsi_device, display, present_mode);
 
    if (!wsi_wl_surface->display)
       wsi_wl_display_finish(&temp_display);
@@ -3481,7 +3485,7 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
       const VkSurfacePresentModeEXT mode =
             { VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT, NULL, pCreateInfo->presentMode };
 
-      uint32_t min_images = wsi_wl_surface_get_min_image_count(wsi_wl_surface->display, &mode);
+      uint32_t min_images = wsi_wl_surface_get_min_image_count(wsi_device, wsi_wl_surface->display, &mode);
       bool requires_image_count_bump = min_images == WSI_WL_BUMPED_NUM_IMAGES;
       if (requires_image_count_bump)
          num_images = MAX2(min_images, num_images);
@@ -3676,7 +3680,8 @@ fail:
 VkResult
 wsi_wl_init_wsi(struct wsi_device *wsi_device,
                 const VkAllocationCallbacks *alloc,
-                VkPhysicalDevice physical_device)
+                VkPhysicalDevice physical_device,
+                const struct driOptionCache *dri_options)
 {
    struct wsi_wayland *wsi;
    VkResult result;
@@ -3702,6 +3707,14 @@ wsi_wl_init_wsi(struct wsi_device *wsi_device,
 
    wsi_device->wsi[VK_ICD_WSI_PLATFORM_WAYLAND] = &wsi->base;
 
+   if (dri_options)
+   {
+      if (driCheckOption(dri_options, "vk_override_min_image_count", DRI_INT)) {
+         wsi_device->wayland.override_minImageCount =
+            driQueryOptioni(dri_options, "vk_override_min_image_count");
+      }
+   }
+
    return VK_SUCCESS;
 
 fail:
diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 2edb7bf2bf3..0f9e2a422c0 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -2924,9 +2924,9 @@ wsi_x11_init_wsi(struct wsi_device *wsi_device,
    }
 
    if (dri_options) {
-      if (driCheckOption(dri_options, "vk_x11_override_min_image_count", DRI_INT)) {
+      if (driCheckOption(dri_options, "vk_override_min_image_count", DRI_INT)) {
          wsi_device->x11.override_minImageCount =
-            driQueryOptioni(dri_options, "vk_x11_override_min_image_count");
+            driQueryOptioni(dri_options, "vk_override_min_image_count");
       }
       if (driCheckOption(dri_options, "vk_x11_strict_image_count", DRI_BOOL)) {
          wsi_device->x11.strict_imageCount =
-- 
2.50.1

